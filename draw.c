#include "draw.h"
#include "images/start_screen.h"
#include "images/board.h"
#include "images/sprites.h"
#include <stdio.h>
#include <stdlib.h>


// TA-TODO: Include any header files for images generated by nin10kit.
// Example for the provided garbage image:
// #include "images/garbage.h"

// TA-TODO: Add any draw/undraw functions for sub-elements of your app here.
// For example, for a snake game, you could have a drawSnake function
// or a drawFood function
//
// e.g.:
// static void drawSnake(Snake* snake);
// static void drawFood(Food* food);

// This function will be used to draw everything about the app
// including the background and whatnot.
void fullDrawAppState(AppState *state) {
	drawFullScreenImageDMA(board);
	drawDeck(state -> opponentDeck);
    drawDeck(state -> playerDeck);
    drawTwoDigitNum(123, WIDTH/2 - 22, state -> playerDeck -> size, WHITE);
    drawTwoDigitNum(26, WIDTH/2 - 22, state -> opponentDeck -> size, WHITE);
    drawTwoDigitNum(CARDXCENTER + 3, WIDTH/2 - 22, state -> pileDeck -> size, WHITE);
}

void drawAppState(AppState *state) {
    switch(state -> state) {
        case 0:
        {
            drawString(5, 5, "PLAYER TURN", WHITE);
            drawTwoDigitNum(123, WIDTH/2 - 22, state -> playerDeck -> size, WHITE);
            drawTwoDigitNum(26, WIDTH/2 - 22, state -> opponentDeck -> size, WHITE);
            drawTwoDigitNum(CARDXCENTER + 3, WIDTH/2 - 22, state -> pileDeck -> size, WHITE);
            int x = state -> playerDeck -> cardBack -> x;
            int y = state -> playerDeck -> cardBack -> y;
            drawRectDMA(x - 1, y - 1, 18, 24, YELLOW);
            break;
        }
        case 1:
        {
            drawString(5, 5, "OPPONENT TURN", WHITE);
            drawTwoDigitNum(123, WIDTH/2 - 22, state -> playerDeck -> size, WHITE);
            drawTwoDigitNum(26, WIDTH/2 - 22, state -> opponentDeck -> size, WHITE);
            drawTwoDigitNum(CARDXCENTER + 3, WIDTH/2 - 22, state -> pileDeck -> size, WHITE);
            int x = state -> opponentDeck -> cardBack -> x;
            int y = state -> opponentDeck -> cardBack -> y;
            drawRectDMA(x - 1, y - 1, 18, 24, YELLOW);
            break;
        }
        case 2:
        {
            drawTwoDigitNum(123, WIDTH/2 - 22, state -> playerDeck -> size, WHITE);
            drawTwoDigitNum(26, WIDTH/2 - 22, state -> opponentDeck -> size, WHITE);
            drawTwoDigitNum(CARDXCENTER + 3, WIDTH/2 - 22, state -> pileDeck -> size, WHITE);
            drawCardBack(state -> hiddenCard);
            drawString(5, 5, "PLACING CARD", WHITE);
            break;
        }
        case 3:
        {
            drawTwoDigitNum(123, WIDTH/2 - 22, state -> playerDeck -> size, WHITE);
            drawTwoDigitNum(26, WIDTH/2 - 22, state -> opponentDeck -> size, WHITE);
            drawTwoDigitNum(CARDXCENTER + 3, WIDTH/2 - 22, state -> pileDeck -> size, WHITE);
            drawSlap(state -> whoSlapped);
            drawString(5, 5, "CARD SLAPPED", WHITE);
            break;
        }
        case 4:
        {
            drawTwoDigitNum(123, WIDTH/2 - 22, state -> playerDeck -> size, WHITE);
            drawTwoDigitNum(26, WIDTH/2 - 22, state -> opponentDeck -> size, WHITE);
            drawTwoDigitNum(CARDXCENTER + 3, WIDTH/2 - 22, state -> pileDeck -> size, WHITE);
            hideCard(state -> pileDeck -> head);
            drawCardBack(state -> hiddenCard);
            drawString(5, 5, "PILE WON", WHITE);
            break;
        }
        case 5:
        {
            drawTwoDigitNum(123, WIDTH/2 - 22, state -> playerDeck -> size, WHITE);
            drawTwoDigitNum(26, WIDTH/2 - 22, state -> opponentDeck -> size, WHITE);
            drawTwoDigitNum(CARDXCENTER + 3, WIDTH/2 - 22, state -> pileDeck -> size, WHITE);
            drawCardBack(state -> hiddenCard);
            drawString(5, 5, "CARD BURNED", WHITE);
            break;
        }
        case 6:
        {
            hideSprites();
            fillScreenDMA(BLACK);
            drawString(10, 5, "CONGRATS! YOU WON!", WHITE);
            drawString(40, 5, "PRESS SELECT TO PLAY AGAIN!", WHITE);
            break;
        }
        case 7:
        {
            hideSprites();
            fillScreenDMA(BLACK);
            drawString(10, 5, "OH NO! YOU LOST!", WHITE);
            drawString(40, 5, "PRESS SELECT TO PLAY AGAIN!", WHITE);
            break;
        }
    }
}

// This function will be used to undraw (i.e. erase) things that might
// move in a frame. E.g. in a Snake game, erase the Snake, the food & the score.
void undrawAppState(AppState *state) {
    switch(state -> state) {
        case 0:
        {
            drawFullScreenImageDMA(board);
            break;
        }
        case 1:
        {
            drawFullScreenImageDMA(board);
            break;
        }
        case 2:
        {
            drawFullScreenImageDMA(board);
            hideCardBack(state -> hiddenCard);
            drawCard(state -> pileDeck -> head);
            break;
        }
        case 3:
        {
            drawFullScreenImageDMA(board);
            hideSlap(state -> whoSlapped);
            break;
        }
        case 4:
        {
            drawFullScreenImageDMA(board);
            hideCardBack(state -> hiddenCard);
            if (state -> pileDeck -> size < 3) {
                drawCard(state -> pileDeck -> head);
            }
            break;
        }
        case 5:
        {
            drawFullScreenImageDMA(board);
            hideCardBack(state -> hiddenCard);
            break;
        }
    }
}


void drawCursor(Cursor *cursor) {
	volatile OamEntry *sprite = getSprite(CURSOR);
	sprite->attr0 = cursor -> x | SPRITES_PALETTE_TYPE | cursor -> sprite_shape;
	sprite->attr1 = cursor -> y | cursor -> sprite_size;
	sprite->attr2 = cursor -> palette_id | cursor -> id;
}

void drawDeck(Deck* deck) {
    CardBack *cardBack = deck -> cardBack;
    drawCardBack(cardBack);
}

void drawCardBack(CardBack *cardBack) {
    volatile OamEntry *sprite = getSprite(cardBack -> shadow);
    sprite->attr0 = cardBack -> x | SPRITES_PALETTE_TYPE | CARDBACK_SPRITE_SHAPE;
    sprite->attr1 = cardBack -> y | CARDBACK_SPRITE_SIZE;
    sprite->attr2 = CARDBACK_PALETTE_ID | CARDBACK_ID;
}

void hideCardBack(CardBack *cardBack) {
    shadow[cardBack -> shadow].attr0 = ATTR0_HIDE;
}

void drawCard(Card* card) {
    volatile OamEntry *sprite = shadow;
    sprite->attr0 = card -> x | SPRITES_PALETTE_TYPE | CARD1_SPRITE_SHAPE;
    sprite->attr1 = card -> y | CARD1_SPRITE_SIZE;
    sprite->attr2 = CARD1_PALETTE_ID | card -> id;
}

void hideCard(Card* card) {
    shadow[CARDSHADOW(card -> suit, card -> value)].attr0 = ATTR0_HIDE;
}

void drawSlap(int turn) {
    int id = PLAYERSLAP_ID;
    int shadow = PLAYERSLAP;
    if (turn == 2) {
        id = OPPONENTSLAP_ID;
        shadow = OPPENENTSLAP;
    }
    volatile OamEntry *sprite = getSprite(shadow);
    sprite->attr0 = CARDXCENTER | SPRITES_PALETTE_TYPE | PLAYERSLAP_SPRITE_SHAPE;
    sprite->attr1 = CARDYCENTER | PLAYERSLAP_SPRITE_SIZE;
    sprite->attr2 = PLAYERSLAP_PALETTE_ID | id;
}

void hideSlap(int turn) {
    int shadowIndex = PLAYERSLAP;
    if (turn == 2) {
        shadowIndex = OPPENENTSLAP;
    }
    shadow[shadowIndex].attr0 = ATTR0_HIDE;

}

void drawTwoDigitNum(int x, int y, int num, u16 color) {
    char str[3];
    str[0] = (char) ('0' + num / 10);
    str[1] = (char) ('0' + num % 10);
    str[2] = '\0';
    drawString(x, y, str, color);
}

void drawOpponents(Opponent opponents[], int arr_size) {
	for (int i = 0; i < arr_size; i++) {
		drawOpponent(&opponents[i]);
	}
}

void drawOpponent(Opponent *opponent) {
	drawImageDMA(opponent -> x, opponent -> y, 64, 64, opponent -> image);
}


void drawStartScreen(void) {
	//drawFullScreenImageDMA();
	drawFullScreenImageDMA(start_screen);
}
