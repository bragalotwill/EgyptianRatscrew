#include "logic.h"
#include "draw.h"
#include "images/sprites.h"
#include "images/uga.h"
#include "images/zvi.h"
#include "images/cs2110.h"
#include "images/buzz.h"
// TA-TODO: Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// AppState enum definition
typedef enum {
    // TA-TODO: Add any additional states you need for your app.
    START,
    CHOOSE_OPPONENT_INIT,
    CHOOSE_OPPONENT,
    INTRODUCE_OPPONENT,
    RULES,
    SLAPPING,
    FACE_CARDS,
    APP_INIT,
    APP,
} GBAState;

int main(void) {
    // TA-TODO: Manipulate REG_DISPCNT here to set Mode 3.
    REG_DISPCNT = MODE3 | BG2_ENABLE | OBJ_ENABLE | SPRITES_DIMENSION_TYPE;
    GBAState state = START;

    // We store the "previous" and "current" states.
    AppState currentAppState, nextAppState;

    // We store the current and previous values of the button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;

    //store sprites
    setUpSprites();
    Cursor cur = {HEIGHT / 2, WIDTH / 2, CURSOR_SPRITE_SHAPE,
    CURSOR_SPRITE_SIZE, CURSOR_PALETTE_ID, CURSOR_ID};
    Cursor *cursor = &cur;

    Opponent possibleOpponents[4];
    Opponent chosen;

    while (1) {
        // Load the current state of the buttons
        currentButtons = BUTTONS;

        // TA-TODO: Manipulate the state machine below as needed.
        switch(state) {
            case START:
            {
                // Wait for VBlank
                waitForVBlank();
                drawStartScreen();
                // TA-TODO: Draw the start state here.
                if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = CHOOSE_OPPONENT_INIT;
                    fillScreenDMA(BLACK);
                } else if (KEY_JUST_PRESSED(BUTTON_B, currentButtons, previousButtons)) {
                    state = RULES;
                    fillScreenDMA(BLACK);
                }
                break;
            }
            case RULES:
            {
                waitForVBlank();
                drawString(5, 5, "HOW TO PLAY:", WHITE);
                drawString(17, 10, "-ERS involves skill and speed", WHITE);
                drawString(29, 10, "-Each player takes half a card deck", WHITE);
                drawString(41, 10, "-Players take turns flipping a card", WHITE);
                drawString(50, 13, "upright in the middle of the table", WHITE);
                drawString(62, 10, "-If certain conditions are met, ", WHITE);
                drawString(71, 13, "players compete to slap the card pile", WHITE);
                drawString(83, 10, "-If a player correctly slaps,", WHITE);
                drawString(92, 13, "they take the card pile", WHITE);
                drawString(104, 10, "-The goal is to have the whole deck", WHITE);
                drawString(116, 10, "-Make sure not to misslap, ", WHITE);
                drawString(125, 13, "or you'll lose a card!", WHITE);
                drawString(145, 10, "PRESS START TO CONTINUE", WHITE);
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                } else if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = SLAPPING;
                    fillScreenDMA(BLACK);
                }
                break;
            }
            case SLAPPING:
            {
                waitForVBlank();
                drawString(5, 5, "WHEN TO SLAP:", WHITE);
                drawString(17, 10, "-Doubles", WHITE);
                drawString(26, 13, "(7, 7) / (4, 4)", WHITE);
                drawString(38, 10, "-Sandwiches", WHITE);
                drawString(47, 13, "(7, 4, 7) / (3, J, 3)", WHITE);
                drawString(59, 10, "-Tens", WHITE);
                drawString(68, 13, "(8, 2) / (A, 1)", WHITE);
                drawString(80, 10, "-Marriage", WHITE);
                drawString(89, 13, "(K, Q) / (Q, K)", WHITE);
                drawString(101, 10, "Slap by pressing A", WHITE);
                drawString(145, 10, "PRESS START TO CONTINUE", WHITE);
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                } else if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = FACE_CARDS;
                    fillScreenDMA(BLACK);
                }
                break;
            }
            case FACE_CARDS:
            {
                waitForVBlank();
                drawString(5, 5, "FACE CARD RULES:", WHITE);
                drawString(17, 10, "-Face Cards (FC) have their own rules", WHITE);
                drawString(29, 10, "-If player 1 plays an FC,", WHITE);
                drawString(38, 13, "player 2 must also place an FC", WHITE);
                drawString(47, 13, "to continue playing the round", WHITE);
                drawString(59, 10, "-Depending on player 1's FC,", WHITE);
                drawString(68, 13, "player 2 has more attempts to continue", WHITE);
                drawString(80, 10, "Jacks   -   1 attempt", WHITE);
                drawString(89, 10, "Queens  -   2 attempts", WHITE);
                drawString(97, 10, "Kings   -   3 attempts", WHITE);
                drawString(106, 10, "Aces    -   4 attempts", WHITE);
                drawString(118, 10, "-Once the attempts are up,", WHITE);
                drawString(127, 13, "the other player takes the card pile", WHITE);
                drawString(145, 10, "PRESS START TO CONTINUE", WHITE);
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                } else if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = CHOOSE_OPPONENT_INIT;
                    fillScreenDMA(BLACK);
                }
                break;
            }
            case CHOOSE_OPPONENT_INIT:
            {
                waitForVBlank();
                Opponent one = {"UGA GRAD", 1, 33, 30, uga};
                Opponent two = {"CS2110 HYDRA", 2, 33, WIDTH/2 + 20, cs2110};
                Opponent three = {"BUZZ YEETERSON", 3, HEIGHT/2 + 20, 30, buzz};
                Opponent four = {"ZVI", 4, HEIGHT/2 + 20, WIDTH/2 + 20, zvi};
                possibleOpponents[0] = one;
                possibleOpponents[1] = two;
                possibleOpponents[2] = three;
                possibleOpponents[3] = four;
                drawOpponents(possibleOpponents, 4);
                drawString(5, 5, "CHOOSE YOUR OPPONENT!", WHITE);
                drawString(15, 5, "ARROW KEYS MOVE CURSOR", WHITE);
                drawString(25, 5, "PRESS A TO SELECT", WHITE);
                state = CHOOSE_OPPONENT;
                break;
            }
            case CHOOSE_OPPONENT:
            {
                int cont = 0;
                if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
                    int x = cursor -> x;
                    int y = cursor -> y;
                    for (int i = 0; i < 4; i++) {
                        Opponent check = possibleOpponents[i];
                        if (x >= check.x && x <= (check.x + 64) && y >= check.y && y < (check.y + 64)) {
                            chosen = check;
                            cont = 1;
                        }
                    }
                } else {
                    if (KEY_DOWN(BUTTON_UP, currentButtons) && cursor -> x >= MIN_CURSOR_X) {
                        cursor -> x -= 2;
                    } else if (KEY_DOWN(BUTTON_DOWN, currentButtons) && cursor -> x <= MAX_CURSOR_X) {
                        cursor -> x += 2;
                    }
                    if (KEY_DOWN(BUTTON_LEFT, currentButtons) && cursor -> y >= MIN_CURSOR_Y) {
                        cursor -> y -= 2;
                    } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && cursor -> y <= MAX_CURSOR_Y) {
                        cursor -> y += 2;
                    }
                }
                waitForVBlank();
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    hideSprites();
                    setSprites();
                    state = START;
                } else if (cont) {
                    hideSprites();
                    setSprites();
                    fillScreenDMA(BLACK);
                    state = INTRODUCE_OPPONENT;
                } else {
                    drawCursor(cursor);
                    // TA-TODO: Check for a button press here to start the app.
                    // Start the app by switching the state to APP_INIT.
                    setSprites();
                }
                break;
            }
            case INTRODUCE_OPPONENT:
            {
                waitForVBlank();
                char message[50], name[50], comma[2];
                strcpy(message, "YOUR OPPONENT IS ");
                strcpy(comma, ",");
                strcpy(name, chosen.name);
                strcat(message, name);
                strcat(message, comma);
                drawString(5, 5, message, WHITE);
                if (chosen.difficulty == 1) {
                    drawString(14, 5, "MASTER OF NOTHING!", WHITE);
                    drawString(44, 5, "PLEASE DONT LOSE", WHITE);
                } else if (chosen.difficulty == 2) {
                    drawString(14, 5, "MASTER OF SPEED!", WHITE);
                    drawString(44, 5, "REMEMBER, THIS IS A TIMED LAB", WHITE);
                } else if (chosen.difficulty == 3) {
                    drawString(14, 5, "MASTER OF STRATEGY!", WHITE);
                    drawString(44, 5, "YOUR GRADUATION WILL BE DELAYED", WHITE);
                } else {
                    drawString(14, 5, "MASTER OF ALL THAT IS!", WHITE);
                    drawString(44, 5, "I FELL FROM MY CHAIR", WHITE);
                }
                drawString(74, 5, "REMEMBER:", WHITE);
                drawString(86, 10, "-PRESS A TO SLAP", WHITE);
                drawString(98, 10, "-PRESS B TO DRAW", WHITE);
                drawString(145, 5, "PRESS START TO CONTINUE", WHITE);
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                } else if(KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = APP_INIT;
                }
                break;
            }
            case APP_INIT:
            {
                currentAppState.opponent = malloc(sizeof(Opponent));
                if (currentAppState.opponent == NULL) {
                    return 1;
                }
                currentAppState.opponent = &chosen;

                initializeAppState(&currentAppState);

                if (currentAppState.mallocError) {
                    return 1;
                }

                waitForVBlank();

                // Draw the initial state of the app
                fullDrawAppState(&currentAppState);

                setSprites();
                state = APP;

                break;
            }
            case APP:
            {
                // Process the app for one frame, store the next state
                nextAppState = processAppState(&currentAppState, previousButtons, currentButtons);

                // Wait for VBlank before we do any drawing.
                waitForVBlank();

                if (nextAppState.state != currentAppState.state) {
                    // Undraw the previous state
                    undrawAppState(&currentAppState);
                }

                // Draw the current state
                drawAppState(&nextAppState);

                // Now set the current state as the next state for the next iter.
                currentAppState = nextAppState;

                setSprites();

                // Check if the app is exiting. If it is, then go to the exit state.
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    hideSprites();
                    setSprites();
                    state = START;
                }
                break;
            }
        }
        // Store the current state of the buttons
        previousButtons = currentButtons;
    }

    return 0;
}
